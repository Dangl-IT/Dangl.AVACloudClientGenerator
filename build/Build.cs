using Newtonsoft.Json.Linq;
using Nuke.Common;
using Nuke.Common.Git;
using Nuke.Common.IO;
using Nuke.Common.Tooling;
using Nuke.Common.Tools.AzureKeyVault;
using Nuke.Common.Tools.Docker;
using Nuke.Common.Tools.DotNet;
using Nuke.Common.Tools.GitVersion;
using Nuke.Common.Utilities.Collections;
using Nuke.GitHub;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using static Nuke.Common.Tooling.ProcessTasks;
using static Nuke.Common.Tools.Docker.DockerTasks;
using static Nuke.Common.Tools.DotNet.DotNetTasks;
using static Nuke.Common.Tools.Git.GitTasks;
using static Nuke.Common.Tools.Npm.NpmTasks;
using static Nuke.GitHub.GitHubTasks;

class Build : NukeBuild
{
    public static int Main() => Execute<Build>(x => x.GenerateAndPublishPythonClient);

    [AzureKeyVaultConfiguration(
        BaseUrlParameterName = nameof(KeyVaultBaseUrl),
        ClientIdParameterName = nameof(KeyVaultClientId),
        ClientSecretParameterName = nameof(KeyVaultClientSecret),
        TenantIdParameterName = nameof(KeyVaultTenantId))]
    readonly AzureKeyVaultConfiguration KeyVaultSettings;

    [Parameter] readonly string KeyVaultBaseUrl;
    [Parameter] readonly string KeyVaultClientId;
    [Parameter] readonly string KeyVaultClientSecret;
    [Parameter] readonly string KeyVaultTenantId;
    [GitVersion(Framework = "netcoreapp3.1")] readonly GitVersion GitVersion;
    [GitRepository] readonly GitRepository GitRepository;

    [Parameter] readonly string NodePublishVersionOverride;
    [Parameter] readonly string DartPublishVersionOverride;
    [Parameter] readonly string PythonClientRepositoryTag;
    [Parameter] readonly string PhpClientRepositoryTag;

    [Parameter] readonly string CustomSwaggerDefinitionUrl;
    [Parameter] readonly string SwaggerGeneratorContainerName = "AVACloudClientGenerator_SwaggerGenerator";

    [Parameter] readonly string Configuration = IsLocalBuild ? "Debug" : "Release";

    [AzureKeyVaultSecret] readonly string GitHubAuthenticationToken;

    AbsolutePath SourceDirectory => RootDirectory / "src";
    AbsolutePath OutputDirectory => RootDirectory / "output";

    Target Clean => _ => _
        .Executes(() =>
        {
            SourceDirectory.GlobDirectories("**/bin", "**/obj").ForEach(d => d.DeleteDirectory());
            (RootDirectory / "test").GlobDirectories("**/bin", "**/obj").ForEach(d => d.DeleteDirectory());
            OutputDirectory.CreateOrCleanDirectory();
        });

    Target Restore => _ => _
        .DependsOn(Clean)
        .Executes(() =>
        {
            DotNetRestore();
        });

    Target GenerateVersion => _ => _
        .Executes(() =>
        {
            var buildDate = DateTime.UtcNow;

            var filePath = SourceDirectory / "Dangl.AVACloudClientGenerator" / "VersionsService.cs";

            var currentDateUtc = $"new DateTime({buildDate.Year}, {buildDate.Month}, {buildDate.Day}, {buildDate.Hour}, {buildDate.Minute}, {buildDate.Second}, DateTimeKind.Utc)";

            var content = $@"using System;

namespace Dangl.AVACloudClientGenerator
{{
    // This file is automatically generated
    [System.CodeDom.Compiler.GeneratedCode(""GitVersionBuild"", """")]
    public static class VersionsService
    {{
        public static string Version => ""{GitVersion.NuGetVersionV2}"";
        public static string CommitInfo => ""{GitVersion.FullBuildMetaData}"";
        public static string CommitDate => ""{GitVersion.CommitDate}"";
        public static string CommitHash => ""{GitVersion.Sha}"";
        public static string InformationalVersion => ""{GitVersion.InformationalVersion}"";
        public static DateTime BuildDateUtc {{ get; }} = {currentDateUtc};
    }}
}}";
            filePath.WriteAllText(content);
        });

    Target Compile => _ => _
        .DependsOn(Restore)
        .DependsOn(GenerateVersion)
        .Executes(() =>
        {
            DotNetBuild(x => x
                .SetConfiguration(Configuration)
                .EnableNoRestore()
                .SetFileVersion(GitVersion.AssemblySemFileVer)
                .SetAssemblyVersion(GitVersion.AssemblySemVer)
                .SetInformationalVersion(GitVersion.InformationalVersion));
        });

    Target Test => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            var testProjects = (RootDirectory / "test").GlobFiles("**/*.csproj");
            var testRun = 1;
            foreach (var testProject in testProjects)
            {
                var projectDirectory = Path.GetDirectoryName(testProject);
                string testFile = OutputDirectory / $"test_{testRun++}.testresults.xml";
                var dotnetPath = ToolPathResolver.GetPathExecutable("dotnet");

                StartProcess(dotnetPath, "test " +
                                         "--no-build " +
                                         "--test-adapter-path:. " +
                                         $"\"--logger:xunit;LogFilePath={testFile}\"",
                        workingDirectory: projectDirectory)
                    // AssertWairForExit() instead of AssertZeroExitCode()
                    // because we want to continue all tests even if some fail
                    .AssertWaitForExit();
            }
        });

    Target Publish => _ => _
        .DependsOn(GenerateClients)
        .Executes(() =>
        {
            var publishDir = OutputDirectory / "publish";
            var zipPath = OutputDirectory / "AVACloud.Client.Generator.zip";

            DotNetPublish(x => x
                .SetConfiguration(Configuration)
                .EnableNoRestore()
                .SetFileVersion(GitVersion.AssemblySemFileVer)
                .SetAssemblyVersion(GitVersion.AssemblySemVer)
                .SetInformationalVersion(GitVersion.InformationalVersion)
                .SetProject(SourceDirectory / "Dangl.AVACloudClientGenerator" / "Dangl.AVACloudClientGenerator.csproj")
                .SetOutput(publishDir));

            System.IO.Compression.ZipFile.CreateFromDirectory(publishDir, zipPath);

            var repositoryInfo = GetGitHubRepositoryInfo(GitRepository);

            var isPrerelease = !(GitVersion.BranchName.Equals("master") || GitVersion.BranchName.Equals("origin/master"));

            var artifactPaths = new string[] { zipPath }.Concat(OutputDirectory.GlobFiles("*.zip").Select(f => f.ToString())).Distinct().ToArray();

            PublishRelease(x => x
                .SetArtifactPaths(artifactPaths)
                .SetCommitSha(GitVersion.Sha)
                .SetRepositoryName(repositoryInfo.repositoryName)
                .SetRepositoryOwner(repositoryInfo.gitHubOwner)
                .SetTag(GitVersion.NuGetVersion)
                .SetPrerelease(isPrerelease)
                .SetToken(GitHubAuthenticationToken))
            .ConfigureAwait(false)
            .GetAwaiter()
            .GetResult();
        });

    Target GenerateClients => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            var languages = new[]
            { 
                "Java",
                "TypeScriptNode",
                // TODO JavaScript client is currently skipped, the generator.swagger.io service always times out
                // "JavaScript",
                "Php",
                "Python",
                "Dart"
            };

            var port = GetFreePort();
            DockerPull(c => c.SetName("swaggerapi/swagger-generator"));
            DockerRun(settings => settings
                .SetImage("swaggerapi/swagger-generator")
                .SetName(SwaggerGeneratorContainerName)
                .SetPublish($"{port}:8080")
                .SetDetach(true)
                .SetRm(true));

            try
            {
                var containerInfo = DockerInspect(settings => settings
                    .SetNames(SwaggerGeneratorContainerName)
                    .SetFormat("{{json .}}"))
                    .FirstOrDefault();

                string swaggerGeneratorClientGenEndpoint = null;
                if (containerInfo.Type == OutputType.Std && !string.IsNullOrWhiteSpace(containerInfo.Text))
                {
                    var containerJson = JObject.Parse(containerInfo.Text);
                    var ipAddress = containerJson?["NetworkSettings"]?["IPAddress"]?.ToString();
                    if (!string.IsNullOrWhiteSpace(ipAddress))
                    {
                        ipAddress = "localhost"; // TODO: should we update this?
                        swaggerGeneratorClientGenEndpoint = $"http://{ipAddress}:{port}/api/gen/clients/";
                    }
                    else
                    {
                        Serilog.Log.Error($"Failed to get IP address for {SwaggerGeneratorContainerName} container");
                    }
                }
                else
                {
                    Serilog.Log.Error($"Failed to get {SwaggerGeneratorContainerName} container info");
                }

                foreach (var language in languages)
                {
                    GenerateClient(language, swaggerGeneratorClientGenEndpoint);
                }
            }
            finally
            {
                DockerStop(settings => settings
                    .SetContainers(SwaggerGeneratorContainerName));
            }
        });

    private int GetFreePort()
    {
        var tcpListener = new TcpListener(IPAddress.Loopback, 0);
        tcpListener.Start();
        int port = ((IPEndPoint)tcpListener.LocalEndpoint).Port;
        tcpListener.Stop();
        return port;
    }

    private void GenerateClient(string language, string outerSwaggerGeneratorClientGenEndpoint = null)
    {
        string swaggerGeneratorClientGenEndpoint = null;
        if (language == "Java" ||
            language == "JavaScript" ||
            language == "Php" ||
            language == "Python")
        {
            if (string.IsNullOrWhiteSpace(outerSwaggerGeneratorClientGenEndpoint))
            {
                var port = "8080"; // TODO: this is hardcoded, since seems like Docker container doesn't work with dynamic ports.
                DockerPull(c => c.SetName("swaggerapi/swagger-generator"));
                DockerRun(settings => settings
                    .SetImage("swaggerapi/swagger-generator")
                    .SetName(SwaggerGeneratorContainerName)
                    .SetPublish($"{port}:{port}")
                    .SetDetach(true)
                    .SetRm(true));

                var containerInfo = DockerInspect(settings => settings
                    .SetNames(SwaggerGeneratorContainerName)
                    .SetFormat("{{json .}}"))
                    .FirstOrDefault();

                if (containerInfo.Type == OutputType.Std && !string.IsNullOrWhiteSpace(containerInfo.Text))
                {
                    var containerJson = JObject.Parse(containerInfo.Text);
                    var ipAddress = containerJson?["NetworkSettings"]?["IPAddress"]?.ToString();
                    if (!string.IsNullOrWhiteSpace(ipAddress))
                    {
                        ipAddress = "localhost"; // TODO: should we update this?
                        swaggerGeneratorClientGenEndpoint = $"http://{ipAddress}:{port}/api/gen/clients/";
                    }
                    else
                    {
                        Serilog.Log.Error($"Failed to get IP address for {SwaggerGeneratorContainerName} container");
                    }
                }
                else
                {
                    Serilog.Log.Error($"Failed to get {SwaggerGeneratorContainerName} container info");
                }
            }
            else
            {
                swaggerGeneratorClientGenEndpoint = outerSwaggerGeneratorClientGenEndpoint;
            }
        }

        var generatorPath = SourceDirectory / "Dangl.AVACloudClientGenerator" / "bin" / Configuration / "net9.0" / "Dangl.AVACloudClientGenerator.dll";
        var outputPath = OutputDirectory / language;
        var arguments = $"\"{generatorPath}\" -l {language} -o \"{outputPath}\"";

        if (!string.IsNullOrWhiteSpace(CustomSwaggerDefinitionUrl))
        {
            Serilog.Log.Information("Using custom Swagger definition url: " + CustomSwaggerDefinitionUrl);
            arguments += $" -u {CustomSwaggerDefinitionUrl}";
        }

        if (!string.IsNullOrWhiteSpace(swaggerGeneratorClientGenEndpoint))
        {
            arguments += $" -s {swaggerGeneratorClientGenEndpoint}";
        }
        else
        {
            if (language == "Java" ||
                language == "JavaScript" ||
                language == "Php" ||
                language == "Python")
            {
                throw new Exception($"The {language} client generator requires a Swagger generator client gen endpoint.");
            }
        }

        StartProcess(ToolPathResolver.GetPathExecutable("dotnet"), arguments)
            .AssertZeroExitCode();

        var zipOutputPath = outputPath.ToString().TrimEnd('/').TrimEnd('\\') + ".zip";
        if (File.Exists(zipOutputPath))
        {
            ((AbsolutePath)zipOutputPath).DeleteFile();
        }

        System.IO.Compression.ZipFile.CreateFromDirectory(outputPath, zipOutputPath);

        if (language == "Java" ||
            language == "JavaScript" ||
            language == "Php" ||
            language == "Python")
        {
            if (string.IsNullOrWhiteSpace(outerSwaggerGeneratorClientGenEndpoint))
            {
                DockerStop(settings => settings
                    .SetContainers(SwaggerGeneratorContainerName));
            }
        }
    }

    Target GenerateAndPublishDartClient => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            GenerateClient("Dart");

            var clientRoot = OutputDirectory / "Dart";


            if (!string.IsNullOrWhiteSpace(DartPublishVersionOverride))
            {
                var pubspecFile = clientRoot / "dart-client" / "pubspec.yaml";
                var content = pubspecFile.ReadAllText();
                var updatedContent = Regex.Split(content, @"\r\n?|\n")
                    .Select(c => c.Trim().StartsWith("version:") ? $"version: {DartPublishVersionOverride}" : c)
                    .Aggregate((c, n) => c + Environment.NewLine + n);
                pubspecFile.WriteAllText(updatedContent);
            }

            (clientRoot / "dart-client" / "CHANGELOG.md").WriteAllText("# Dangl AVACloud Client"
                + Environment.NewLine
                + (DartPublishVersionOverride ?? GitVersion.NuGetVersion));
            (clientRoot / "LICENSE.md").Move(clientRoot / "dart-client" / "LICENSE");

            var tempFolder = RootDirectory / "temp-publish";
            tempFolder.CreateOrCleanDirectory();
            tempFolder.DeleteDirectory();
            Task.Delay(100).Wait(); // There are sometimes timing issues with folder access
            try
            {
                (clientRoot / "dart-client").Move(tempFolder);

                StartProcess("dart", "pub publish -f", workingDirectory: tempFolder)
                    .AssertZeroExitCode();
            }
            finally
            {
                tempFolder.DeleteDirectory();
            }
        });

    Target GenerateAndPublishTypeScriptNpmClient => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            GenerateClient("TypeScriptNode");

            var clientRoot = OutputDirectory / "TypeScriptNode";

            if (!string.IsNullOrWhiteSpace(NodePublishVersionOverride))
            {
                try
                {
                    Npm($"version {NodePublishVersionOverride}", clientRoot);
                }
                catch
                {
                    // We're ignoring errors when setting the version, since it could happen
                    // that the auto generated one matches the one we're specifying, and that would
                    // result in an error from npm since the version wasn't changed.
                }
            }

            NpmInstall(x => x.SetProcessWorkingDirectory(clientRoot));
            NpmRun(x => x.SetProcessWorkingDirectory(clientRoot).AddProcessAdditionalArguments("build"));

            Npm("publish --access=public", clientRoot);
        });

    Target GenerateAndPublishJavaScriptNpmClient => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            GenerateClient("JavaScript");

            var clientRoot = OutputDirectory / "JavaScript";
            var clientDir = clientRoot / "javascript-client";

            (clientDir / "README.md").Move(clientDir / "API_README.md");
            (clientRoot / "README.md").Copy(clientDir / "README.md");
            (clientRoot / "LICENSE.md").Copy(clientDir / "LICENSE.md");

            if (!string.IsNullOrWhiteSpace(NodePublishVersionOverride))
            {
                try
                {
                    Npm($"version {NodePublishVersionOverride}", clientDir);
                }
                catch
                {
                    // We're ignoring errors when setting the version, since it could happen
                    // that the auto generated one matches the one we're specifying, and that would
                    // result in an error from npm since the version wasn't changed.
                }
            }

            NpmInstall(x => x.SetProcessWorkingDirectory(clientDir));
            NpmRun(x => x.SetProcessWorkingDirectory(clientDir).AddProcessAdditionalArguments("build"));

            Npm("publish --access=public", clientDir);
        });

    Target GenerateAndPublishPythonClient => _ => _
        .DependsOn(Compile)
        .Requires(() => PythonClientRepositoryTag)
        .Executes(async () =>
        {
            await GenerateAndPushPythonCode("master", PythonClientRepositoryTag, false);
            OutputDirectory.CreateOrCleanDirectory();
            await GenerateAndPushPythonCode("python3", $"{PythonClientRepositoryTag}-V3", true);
        });

    private async Task GenerateAndPushPythonCode(string branchName,
        string tag,
        bool transformToV3)
    {
        var clientRoot = OutputDirectory / "Python";
        var clientDir = clientRoot / "python-client";

        clientRoot.CreateOrCleanDirectory();
        clientDir.CreateOrCleanDirectory();

        GenerateClient("Python");

        (clientDir / "README.md").Move(clientDir / "API_README.md");
        (clientRoot / "README.md").Copy(clientDir / "README.md");
        (clientRoot / "LICENSE.md").Copy(clientDir / "LICENSE.md");

        var mirrorRepoDir = OutputDirectory / "MirrorRepo";
        Directory.CreateDirectory(mirrorRepoDir);
        var mirrorRepoUrl = "https://github.com/Dangl-IT/avacloud-client-python.git";

        try
        {
            Git($"clone {mirrorRepoUrl} -b {branchName}", mirrorRepoDir)?.ToList().ForEach(x => Serilog.Log.Information(x.Text));
        }
        catch
        {
            // If the branch doesn't exist, it should be created
            Git($"clone {mirrorRepoUrl}", mirrorRepoDir)?.ToList().ForEach(x => Serilog.Log.Information(x.Text));
        }

        mirrorRepoDir = mirrorRepoDir / "avacloud-client-python";

        // Delete all but .git/ in cloned repo
        var dirs = Directory.EnumerateDirectories(mirrorRepoDir)
            .Where(d => !d.EndsWith(".git", StringComparison.OrdinalIgnoreCase));
        dirs.ForEach(d => ((AbsolutePath)d).DeleteDirectory());
        var files = Directory.EnumerateFiles(mirrorRepoDir)
            .ToList();
        files.ForEach(File.Delete);
        // Copy data into cloned repo
        var dirsToCopy = Directory.EnumerateDirectories(clientDir)
            .Select(d => (AbsolutePath)d)
            .ToList();
        dirsToCopy.ForEach(d =>
        {
            var folderName = Path.GetFileName(d);
            d.CopyToDirectory(mirrorRepoDir / folderName);
        });
        var filesToCopy = Directory.EnumerateFiles(clientDir)
            .ToList();
        filesToCopy.ForEach(f =>
        {
            var fileName = Path.GetFileName(f);
            File.Copy(f, mirrorRepoDir / fileName);
        });

        if (transformToV3)
        {
            // Now, we also want to ensure that we have a Python3 client available
            var pythonSourceFiles = mirrorRepoDir.GlobFiles("**/*.py");
            using var httpClient = new HttpClient();
            Serilog.Log.Information($"Transforming {pythonSourceFiles.Count} source files to Python3");
            foreach (var pythonSourceFile in pythonSourceFiles)
            {
                // We're converting them serially, since there seems to be some rate limiting on the service
                // we're using to convert to Python3 otherwise.
                Serilog.Log.Information("Converting file to Python3: " + pythonSourceFile.ToString());
                await ConvertFileFromPython2ToPython3Async(pythonSourceFile, httpClient);
            }
        }

        Git("add -A", workingDirectory: mirrorRepoDir);
        var commitMessage = "Auto generated commit";
        Git($"commit -m {commitMessage}", workingDirectory: mirrorRepoDir);
        Git($"tag {tag}", workingDirectory: mirrorRepoDir);
        Git($"push --set-upstream origin {branchName}", workingDirectory: mirrorRepoDir);
        Git("push --tags", workingDirectory: mirrorRepoDir);
    }

    private async Task ConvertFileFromPython2ToPython3Async(AbsolutePath filePath, HttpClient httpClient)
    {
        var python2Code = filePath.ReadAllText();

        var formValue = new Dictionary<string, string>
        {
            { "input", python2Code }
        };
        var formContent = new FormUrlEncodedContent(formValue);
        var request = new HttpRequestMessage(HttpMethod.Post, "https://python2to3.com/");
        request.Content = formContent;

        var response = await httpClient.SendAsync(request);
        Assert.True(response.IsSuccessStatusCode);
        var responseHtml = await response.Content.ReadAsStringAsync();
        var htmlDoc = new HtmlAgilityPack.HtmlDocument();
        htmlDoc.LoadHtml(responseHtml);
        var python3Code = htmlDoc.DocumentNode.SelectSingleNode("//textarea[@id='result-val']").InnerText;
        python3Code = HttpUtility.HtmlDecode(python3Code);

        filePath.WriteAllText(python3Code);
    }

    Target GenerateAndPublishPhpClient => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            GenerateClient("Php");

            var composerJsonFile = OutputDirectory.GlobFiles("**/*composer.json").Single();
            var composerJson = composerJsonFile.ReadAllText();
            var composerJObject = JObject.Parse(composerJson);
            var composerVersion = string.IsNullOrWhiteSpace(PhpClientRepositoryTag)
                ? GitVersion.NuGetVersion
                : PhpClientRepositoryTag;
            composerJObject["version"] = composerVersion;
            composerJsonFile.WriteAllText(composerJObject.ToString());


            var clientRoot = OutputDirectory / "Php";
            var clientDir = clientRoot / "php-client" / "Dangl" / "AVACloud";

            (clientRoot / "README.md").Copy(clientDir / "CLIENT_README.md");
            (clientRoot / "LICENSE.md").Copy(clientDir / "LICENSE.md");

            var mirrorRepoDir = OutputDirectory / "MirrorRepo";
            Directory.CreateDirectory(mirrorRepoDir);
            var mirrorBranchName = "master";
            var mirrorRepoUrl = "https://github.com/Dangl-IT/avacloud-client-php.git";

            try
            {
                Git($"clone {mirrorRepoUrl} {mirrorRepoDir} -b {mirrorBranchName}", mirrorRepoDir)?.ToList().ForEach(x => Serilog.Log.Information(x.Text));
            }
            catch
            {
                // If the branch doesn't exist, it should be created
                Git($"clone {mirrorRepoUrl}", mirrorRepoDir)?.ToList().ForEach(x => Serilog.Log.Information(x.Text));
            }

            // Delete all but .git/ in cloned repo
            var dirs = Directory.EnumerateDirectories(mirrorRepoDir)
                .Where(d => !d.EndsWith(".git", StringComparison.OrdinalIgnoreCase));
            dirs.ForEach(d => ((AbsolutePath)d).DeleteDirectory());
            var files = Directory.EnumerateFiles(mirrorRepoDir)
                .ToList();
            files.ForEach(File.Delete);
            // Copy data into cloned repo
            var dirsToCopy = Directory.EnumerateDirectories(clientDir)
                .Select(d => (AbsolutePath)d)
                .ToList();
            dirsToCopy.ForEach(d =>
            {
                var folderName = Path.GetFileName(d);
                d.CopyToDirectory(mirrorRepoDir / folderName);
            });
            var filesToCopy = Directory.EnumerateFiles(clientDir)
                .ToList();
            filesToCopy.ForEach(f =>
            {
                var fileName = Path.GetFileName(f);
                File.Copy(f, mirrorRepoDir / fileName);
            });

            var phpClientTag = PhpClientRepositoryTag;
            if (string.IsNullOrWhiteSpace(phpClientTag))
            {
                phpClientTag =$"v{GitVersion.NuGetVersion}";
            }

            Git("add -A", workingDirectory: mirrorRepoDir);
            var commitMessage = "Auto generated commit";
            Git($"commit -m {commitMessage}", workingDirectory: mirrorRepoDir);
            Git($"tag {phpClientTag}", workingDirectory: mirrorRepoDir);
            Git($"push --set-upstream origin {mirrorBranchName}", workingDirectory: mirrorRepoDir);
            Git("push --tags", workingDirectory: mirrorRepoDir);
        });
}
